#version 330
layout (points) in;
layout (triangle_strip, max_vertices = 4) out;


in VS_OUT {
	float tileId;
} gs_in[];



out vec2 fClip; // Output to fragment shader


uniform vec2 tileSize;
uniform vec2 setSize;
uniform vec2 orthoVec;


void main() {

	//Calculate offset

	int tId = int(gs_in[0].tileId);

	int tilesPerLine = int(floor(setSize.x / tileSize.x));

	vec2 translate = vec2(
		float(tId % tilesPerLine),
		floor(float(tId / tilesPerLine))
	);

	vec2 setTransform = vec2(1.0/setSize.x, 1.0/setSize.y);


	vec2 transformedSize = tileSize * orthoVec;

	vec2 clipSize = setTransform * tileSize;


	vec2 clipTranslate = clipSize * translate ;

	vec4 transformedPosition = gl_in[0].gl_Position;



	transformedPosition.x = (transformedPosition.x * orthoVec.x) -1.0;
	transformedPosition.y = 1.0 - ((transformedPosition.y + tileSize.y) * orthoVec.y);


	fClip  = vec2(clipSize.x,clipSize.y) + clipTranslate;
    gl_Position = transformedPosition + vec4(0.0, 0.0, 0.0, 0.0);
    EmitVertex();

	fClip  = vec2(0, clipSize.y) + clipTranslate;

    gl_Position = transformedPosition + vec4( transformedSize.x, 0.0, 0.0, 0.0);
    EmitVertex();

	fClip  = vec2(clipSize.x,0) + clipTranslate;
	gl_Position = transformedPosition + vec4( 0.0, transformedSize.y, 0.0, 0.0);
    EmitVertex();

	fClip  = vec2(0,0) + clipTranslate;
	gl_Position = transformedPosition + vec4( transformedSize.x, transformedSize.y, 0.0, 0.0);
    EmitVertex();

    EndPrimitive();
}
